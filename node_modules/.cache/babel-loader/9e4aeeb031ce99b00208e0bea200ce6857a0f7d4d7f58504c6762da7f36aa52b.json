{"ast":null,"code":"import { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\nexport class ObjectWrappingMap {\n  constructor(object) {\n    this.wrappedObject = object;\n    this[Symbol.iterator] = this.entries;\n  }\n  keys() {\n    return Object.keys(this.wrappedObject).values();\n  }\n  get(key) {\n    return getSafeProperty(this.wrappedObject, key);\n  }\n  set(key, value) {\n    setSafeProperty(this.wrappedObject, key, value);\n    return this;\n  }\n  has(key) {\n    return hasSafeProperty(this.wrappedObject, key);\n  }\n  entries() {\n    return mapIterator(this.keys(), key => [key, this.get(key)]);\n  }\n  forEach(callback) {\n    for (var key of this.keys()) {\n      callback(this.get(key), key, this);\n    }\n  }\n  delete(key) {\n    delete this.wrappedObject[key];\n  }\n  clear() {\n    for (var key of this.keys()) {\n      this.delete(key);\n    }\n  }\n  get size() {\n    return Object.keys(this.wrappedObject).length;\n  }\n}\n\n/**\n * Create a map with two partitions: a and b.\n * The set with bKeys determines which keys/values are read/written to map b,\n * all other values are read/written to map a\n *\n * For example:\n *\n *   const a = new Map()\n *   const b = new Map()\n *   const p = new PartitionedMap(a, b, new Set(['x', 'y']))\n *\n * In this case, values `x` and `y` are read/written to map `b`,\n * all other values are read/written to map `a`.\n */\nexport class PartitionedMap {\n  /**\n   * @param {Map} a\n   * @param {Map} b\n   * @param {Set} bKeys\n   */\n  constructor(a, b, bKeys) {\n    this.a = a;\n    this.b = b;\n    this.bKeys = bKeys;\n    this[Symbol.iterator] = this.entries;\n  }\n  get(key) {\n    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);\n  }\n  set(key, value) {\n    if (this.bKeys.has(key)) {\n      this.b.set(key, value);\n    } else {\n      this.a.set(key, value);\n    }\n    return this;\n  }\n  has(key) {\n    return this.b.has(key) || this.a.has(key);\n  }\n  keys() {\n    return new Set([...this.a.keys(), ...this.b.keys()])[Symbol.iterator]();\n  }\n  entries() {\n    return mapIterator(this.keys(), key => [key, this.get(key)]);\n  }\n  forEach(callback) {\n    for (var key of this.keys()) {\n      callback(this.get(key), key, this);\n    }\n  }\n  delete(key) {\n    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);\n  }\n  clear() {\n    this.a.clear();\n    this.b.clear();\n  }\n  get size() {\n    return [...this.keys()].length;\n  }\n}\n\n/**\n * Create a new iterator that maps over the provided iterator, applying a mapping function to each item\n */\nfunction mapIterator(it, callback) {\n  return {\n    next: () => {\n      var n = it.next();\n      return n.done ? n : {\n        value: callback(n.value),\n        done: false\n      };\n    }\n  };\n}\n\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\nexport function createEmptyMap() {\n  return new Map();\n}\n\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n  throw new Error('createMap can create maps from objects or Maps');\n}\n\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n  var object = {};\n  for (var key of map.keys()) {\n    var value = map.get(key);\n    setSafeProperty(object, key, value);\n  }\n  return object;\n}\n\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n  for (var args of objects) {\n    if (!args) {\n      continue;\n    }\n    if (isMap(args)) {\n      for (var key of args.keys()) {\n        map.set(key, args.get(key));\n      }\n    } else if (isObject(args)) {\n      for (var _key2 of Object.keys(args)) {\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n  return map;\n}","map":{"version":3,"names":["setSafeProperty","hasSafeProperty","getSafeProperty","isObject","ObjectWrappingMap","constructor","object","wrappedObject","Symbol","iterator","entries","keys","Object","values","get","key","set","value","has","mapIterator","forEach","callback","delete","clear","size","length","PartitionedMap","a","b","bKeys","Set","it","next","n","done","createEmptyMap","Map","createMap","mapOrObject","isMap","Error","toObject","map","assign","_len","arguments","objects","Array","_key","args","_key2"],"sources":["G:/New folder (2)/today_pay/node_modules/mathjs/lib/esm/utils/map.js"],"sourcesContent":["import { setSafeProperty, hasSafeProperty, getSafeProperty } from './customs.js';\nimport { isObject } from './is.js';\n\n/**\n * A map facade on a bare object.\n *\n * The small number of methods needed to implement a scope,\n * forwarding on to the SafeProperty functions. Over time, the codebase\n * will stop using this method, as all objects will be Maps, rather than\n * more security prone objects.\n */\nexport class ObjectWrappingMap {\n  constructor(object) {\n    this.wrappedObject = object;\n    this[Symbol.iterator] = this.entries;\n  }\n  keys() {\n    return Object.keys(this.wrappedObject).values();\n  }\n  get(key) {\n    return getSafeProperty(this.wrappedObject, key);\n  }\n  set(key, value) {\n    setSafeProperty(this.wrappedObject, key, value);\n    return this;\n  }\n  has(key) {\n    return hasSafeProperty(this.wrappedObject, key);\n  }\n  entries() {\n    return mapIterator(this.keys(), key => [key, this.get(key)]);\n  }\n  forEach(callback) {\n    for (var key of this.keys()) {\n      callback(this.get(key), key, this);\n    }\n  }\n  delete(key) {\n    delete this.wrappedObject[key];\n  }\n  clear() {\n    for (var key of this.keys()) {\n      this.delete(key);\n    }\n  }\n  get size() {\n    return Object.keys(this.wrappedObject).length;\n  }\n}\n\n/**\n * Create a map with two partitions: a and b.\n * The set with bKeys determines which keys/values are read/written to map b,\n * all other values are read/written to map a\n *\n * For example:\n *\n *   const a = new Map()\n *   const b = new Map()\n *   const p = new PartitionedMap(a, b, new Set(['x', 'y']))\n *\n * In this case, values `x` and `y` are read/written to map `b`,\n * all other values are read/written to map `a`.\n */\nexport class PartitionedMap {\n  /**\n   * @param {Map} a\n   * @param {Map} b\n   * @param {Set} bKeys\n   */\n  constructor(a, b, bKeys) {\n    this.a = a;\n    this.b = b;\n    this.bKeys = bKeys;\n    this[Symbol.iterator] = this.entries;\n  }\n  get(key) {\n    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);\n  }\n  set(key, value) {\n    if (this.bKeys.has(key)) {\n      this.b.set(key, value);\n    } else {\n      this.a.set(key, value);\n    }\n    return this;\n  }\n  has(key) {\n    return this.b.has(key) || this.a.has(key);\n  }\n  keys() {\n    return new Set([...this.a.keys(), ...this.b.keys()])[Symbol.iterator]();\n  }\n  entries() {\n    return mapIterator(this.keys(), key => [key, this.get(key)]);\n  }\n  forEach(callback) {\n    for (var key of this.keys()) {\n      callback(this.get(key), key, this);\n    }\n  }\n  delete(key) {\n    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);\n  }\n  clear() {\n    this.a.clear();\n    this.b.clear();\n  }\n  get size() {\n    return [...this.keys()].length;\n  }\n}\n\n/**\n * Create a new iterator that maps over the provided iterator, applying a mapping function to each item\n */\nfunction mapIterator(it, callback) {\n  return {\n    next: () => {\n      var n = it.next();\n      return n.done ? n : {\n        value: callback(n.value),\n        done: false\n      };\n    }\n  };\n}\n\n/**\n * Creates an empty map, or whatever your platform's polyfill is.\n *\n * @returns an empty Map or Map like object.\n */\nexport function createEmptyMap() {\n  return new Map();\n}\n\n/**\n * Creates a Map from the given object.\n *\n * @param { Map | { [key: string]: unknown } | undefined } mapOrObject\n * @returns\n */\nexport function createMap(mapOrObject) {\n  if (!mapOrObject) {\n    return createEmptyMap();\n  }\n  if (isMap(mapOrObject)) {\n    return mapOrObject;\n  }\n  if (isObject(mapOrObject)) {\n    return new ObjectWrappingMap(mapOrObject);\n  }\n  throw new Error('createMap can create maps from objects or Maps');\n}\n\n/**\n * Unwraps a map into an object.\n *\n * @param {Map} map\n * @returns { [key: string]: unknown }\n */\nexport function toObject(map) {\n  if (map instanceof ObjectWrappingMap) {\n    return map.wrappedObject;\n  }\n  var object = {};\n  for (var key of map.keys()) {\n    var value = map.get(key);\n    setSafeProperty(object, key, value);\n  }\n  return object;\n}\n\n/**\n * Returns `true` if the passed object appears to be a Map (i.e. duck typing).\n *\n * Methods looked for are `get`, `set`, `keys` and `has`.\n *\n * @param {Map | object} object\n * @returns\n */\nexport function isMap(object) {\n  // We can use the fast instanceof, or a slower duck typing check.\n  // The duck typing method needs to cover enough methods to not be confused with DenseMatrix.\n  if (!object) {\n    return false;\n  }\n  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === 'function' && typeof object.get === 'function' && typeof object.keys === 'function' && typeof object.has === 'function';\n}\n\n/**\n * Copies the contents of key-value pairs from each `objects` in to `map`.\n *\n * Object is `objects` can be a `Map` or object.\n *\n * This is the `Map` analog to `Object.assign`.\n */\nexport function assign(map) {\n  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n  for (var args of objects) {\n    if (!args) {\n      continue;\n    }\n    if (isMap(args)) {\n      for (var key of args.keys()) {\n        map.set(key, args.get(key));\n      }\n    } else if (isObject(args)) {\n      for (var _key2 of Object.keys(args)) {\n        map.set(_key2, args[_key2]);\n      }\n    }\n  }\n  return map;\n}"],"mappings":"AAAA,SAASA,eAAe,EAAEC,eAAe,EAAEC,eAAe,QAAQ,cAAc;AAChF,SAASC,QAAQ,QAAQ,SAAS;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;EAC7BC,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAI,CAACC,aAAa,GAAGD,MAAM;IAC3B,IAAI,CAACE,MAAM,CAACC,QAAQ,CAAC,GAAG,IAAI,CAACC,OAAO;EACtC;EACAC,IAAIA,CAAA,EAAG;IACL,OAAOC,MAAM,CAACD,IAAI,CAAC,IAAI,CAACJ,aAAa,CAAC,CAACM,MAAM,CAAC,CAAC;EACjD;EACAC,GAAGA,CAACC,GAAG,EAAE;IACP,OAAOb,eAAe,CAAC,IAAI,CAACK,aAAa,EAAEQ,GAAG,CAAC;EACjD;EACAC,GAAGA,CAACD,GAAG,EAAEE,KAAK,EAAE;IACdjB,eAAe,CAAC,IAAI,CAACO,aAAa,EAAEQ,GAAG,EAAEE,KAAK,CAAC;IAC/C,OAAO,IAAI;EACb;EACAC,GAAGA,CAACH,GAAG,EAAE;IACP,OAAOd,eAAe,CAAC,IAAI,CAACM,aAAa,EAAEQ,GAAG,CAAC;EACjD;EACAL,OAAOA,CAAA,EAAG;IACR,OAAOS,WAAW,CAAC,IAAI,CAACR,IAAI,CAAC,CAAC,EAAEI,GAAG,IAAI,CAACA,GAAG,EAAE,IAAI,CAACD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC;EAC9D;EACAK,OAAOA,CAACC,QAAQ,EAAE;IAChB,KAAK,IAAIN,GAAG,IAAI,IAAI,CAACJ,IAAI,CAAC,CAAC,EAAE;MAC3BU,QAAQ,CAAC,IAAI,CAACP,GAAG,CAACC,GAAG,CAAC,EAAEA,GAAG,EAAE,IAAI,CAAC;IACpC;EACF;EACAO,MAAMA,CAACP,GAAG,EAAE;IACV,OAAO,IAAI,CAACR,aAAa,CAACQ,GAAG,CAAC;EAChC;EACAQ,KAAKA,CAAA,EAAG;IACN,KAAK,IAAIR,GAAG,IAAI,IAAI,CAACJ,IAAI,CAAC,CAAC,EAAE;MAC3B,IAAI,CAACW,MAAM,CAACP,GAAG,CAAC;IAClB;EACF;EACA,IAAIS,IAAIA,CAAA,EAAG;IACT,OAAOZ,MAAM,CAACD,IAAI,CAAC,IAAI,CAACJ,aAAa,CAAC,CAACkB,MAAM;EAC/C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,CAAC;EAC1B;AACF;AACA;AACA;AACA;EACErB,WAAWA,CAACsB,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAE;IACvB,IAAI,CAACF,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,CAAC,GAAGA,CAAC;IACV,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACrB,MAAM,CAACC,QAAQ,CAAC,GAAG,IAAI,CAACC,OAAO;EACtC;EACAI,GAAGA,CAACC,GAAG,EAAE;IACP,OAAO,IAAI,CAACc,KAAK,CAACX,GAAG,CAACH,GAAG,CAAC,GAAG,IAAI,CAACa,CAAC,CAACd,GAAG,CAACC,GAAG,CAAC,GAAG,IAAI,CAACY,CAAC,CAACb,GAAG,CAACC,GAAG,CAAC;EAChE;EACAC,GAAGA,CAACD,GAAG,EAAEE,KAAK,EAAE;IACd,IAAI,IAAI,CAACY,KAAK,CAACX,GAAG,CAACH,GAAG,CAAC,EAAE;MACvB,IAAI,CAACa,CAAC,CAACZ,GAAG,CAACD,GAAG,EAAEE,KAAK,CAAC;IACxB,CAAC,MAAM;MACL,IAAI,CAACU,CAAC,CAACX,GAAG,CAACD,GAAG,EAAEE,KAAK,CAAC;IACxB;IACA,OAAO,IAAI;EACb;EACAC,GAAGA,CAACH,GAAG,EAAE;IACP,OAAO,IAAI,CAACa,CAAC,CAACV,GAAG,CAACH,GAAG,CAAC,IAAI,IAAI,CAACY,CAAC,CAACT,GAAG,CAACH,GAAG,CAAC;EAC3C;EACAJ,IAAIA,CAAA,EAAG;IACL,OAAO,IAAImB,GAAG,CAAC,CAAC,GAAG,IAAI,CAACH,CAAC,CAAChB,IAAI,CAAC,CAAC,EAAE,GAAG,IAAI,CAACiB,CAAC,CAACjB,IAAI,CAAC,CAAC,CAAC,CAAC,CAACH,MAAM,CAACC,QAAQ,CAAC,CAAC,CAAC;EACzE;EACAC,OAAOA,CAAA,EAAG;IACR,OAAOS,WAAW,CAAC,IAAI,CAACR,IAAI,CAAC,CAAC,EAAEI,GAAG,IAAI,CAACA,GAAG,EAAE,IAAI,CAACD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC;EAC9D;EACAK,OAAOA,CAACC,QAAQ,EAAE;IAChB,KAAK,IAAIN,GAAG,IAAI,IAAI,CAACJ,IAAI,CAAC,CAAC,EAAE;MAC3BU,QAAQ,CAAC,IAAI,CAACP,GAAG,CAACC,GAAG,CAAC,EAAEA,GAAG,EAAE,IAAI,CAAC;IACpC;EACF;EACAO,MAAMA,CAACP,GAAG,EAAE;IACV,OAAO,IAAI,CAACc,KAAK,CAACX,GAAG,CAACH,GAAG,CAAC,GAAG,IAAI,CAACa,CAAC,CAACN,MAAM,CAACP,GAAG,CAAC,GAAG,IAAI,CAACY,CAAC,CAACL,MAAM,CAACP,GAAG,CAAC;EACtE;EACAQ,KAAKA,CAAA,EAAG;IACN,IAAI,CAACI,CAAC,CAACJ,KAAK,CAAC,CAAC;IACd,IAAI,CAACK,CAAC,CAACL,KAAK,CAAC,CAAC;EAChB;EACA,IAAIC,IAAIA,CAAA,EAAG;IACT,OAAO,CAAC,GAAG,IAAI,CAACb,IAAI,CAAC,CAAC,CAAC,CAACc,MAAM;EAChC;AACF;;AAEA;AACA;AACA;AACA,SAASN,WAAWA,CAACY,EAAE,EAAEV,QAAQ,EAAE;EACjC,OAAO;IACLW,IAAI,EAAEA,CAAA,KAAM;MACV,IAAIC,CAAC,GAAGF,EAAE,CAACC,IAAI,CAAC,CAAC;MACjB,OAAOC,CAAC,CAACC,IAAI,GAAGD,CAAC,GAAG;QAClBhB,KAAK,EAAEI,QAAQ,CAACY,CAAC,CAAChB,KAAK,CAAC;QACxBiB,IAAI,EAAE;MACR,CAAC;IACH;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAAA,EAAG;EAC/B,OAAO,IAAIC,GAAG,CAAC,CAAC;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,WAAW,EAAE;EACrC,IAAI,CAACA,WAAW,EAAE;IAChB,OAAOH,cAAc,CAAC,CAAC;EACzB;EACA,IAAII,KAAK,CAACD,WAAW,CAAC,EAAE;IACtB,OAAOA,WAAW;EACpB;EACA,IAAInC,QAAQ,CAACmC,WAAW,CAAC,EAAE;IACzB,OAAO,IAAIlC,iBAAiB,CAACkC,WAAW,CAAC;EAC3C;EACA,MAAM,IAAIE,KAAK,CAAC,gDAAgD,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,GAAG,EAAE;EAC5B,IAAIA,GAAG,YAAYtC,iBAAiB,EAAE;IACpC,OAAOsC,GAAG,CAACnC,aAAa;EAC1B;EACA,IAAID,MAAM,GAAG,CAAC,CAAC;EACf,KAAK,IAAIS,GAAG,IAAI2B,GAAG,CAAC/B,IAAI,CAAC,CAAC,EAAE;IAC1B,IAAIM,KAAK,GAAGyB,GAAG,CAAC5B,GAAG,CAACC,GAAG,CAAC;IACxBf,eAAe,CAACM,MAAM,EAAES,GAAG,EAAEE,KAAK,CAAC;EACrC;EACA,OAAOX,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiC,KAAKA,CAACjC,MAAM,EAAE;EAC5B;EACA;EACA,IAAI,CAACA,MAAM,EAAE;IACX,OAAO,KAAK;EACd;EACA,OAAOA,MAAM,YAAY8B,GAAG,IAAI9B,MAAM,YAAYF,iBAAiB,IAAI,OAAOE,MAAM,CAACU,GAAG,KAAK,UAAU,IAAI,OAAOV,MAAM,CAACQ,GAAG,KAAK,UAAU,IAAI,OAAOR,MAAM,CAACK,IAAI,KAAK,UAAU,IAAI,OAAOL,MAAM,CAACY,GAAG,KAAK,UAAU;AACtN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASyB,MAAMA,CAACD,GAAG,EAAE;EAC1B,KAAK,IAAIE,IAAI,GAAGC,SAAS,CAACpB,MAAM,EAAEqB,OAAO,GAAG,IAAIC,KAAK,CAACH,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEI,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGJ,IAAI,EAAEI,IAAI,EAAE,EAAE;IAC7GF,OAAO,CAACE,IAAI,GAAG,CAAC,CAAC,GAAGH,SAAS,CAACG,IAAI,CAAC;EACrC;EACA,KAAK,IAAIC,IAAI,IAAIH,OAAO,EAAE;IACxB,IAAI,CAACG,IAAI,EAAE;MACT;IACF;IACA,IAAIV,KAAK,CAACU,IAAI,CAAC,EAAE;MACf,KAAK,IAAIlC,GAAG,IAAIkC,IAAI,CAACtC,IAAI,CAAC,CAAC,EAAE;QAC3B+B,GAAG,CAAC1B,GAAG,CAACD,GAAG,EAAEkC,IAAI,CAACnC,GAAG,CAACC,GAAG,CAAC,CAAC;MAC7B;IACF,CAAC,MAAM,IAAIZ,QAAQ,CAAC8C,IAAI,CAAC,EAAE;MACzB,KAAK,IAAIC,KAAK,IAAItC,MAAM,CAACD,IAAI,CAACsC,IAAI,CAAC,EAAE;QACnCP,GAAG,CAAC1B,GAAG,CAACkC,KAAK,EAAED,IAAI,CAACC,KAAK,CAAC,CAAC;MAC7B;IACF;EACF;EACA,OAAOR,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}